<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris – Vanilla JS</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #121829;
      --text: #e7ecff;
      --muted: #94a3b8;
      --accent: #6ee7ff;
      --grid: #1f2937;
      --ghost: #334155;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
      Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: radial-gradient(1200px 800px at 10% 10%, #0f172a, #0b0f1a);
      color: var(--text); display: grid; place-items: center;
    }
    .app { display: grid; grid-template-columns: 220px 360px 220px; gap: 16px; align-items: start; }
    @media (max-width: 860px) {
      .app { grid-template-columns: 1fr; place-items: center; }
      .side { width: 360px; }
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08); border-radius: 16px; padding: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .title { font-weight: 800; letter-spacing: 0.2px; font-size: 18px; margin: 0 0 10px; color: var(--accent); text-transform: uppercase; }
    .meta { color: var(--muted); font-size: 14px; line-height: 1.4; }
    .kbd { display: inline-block; padding: 2px 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.04); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    canvas { display: block; background: var(--panel); border-radius: 16px; border: 1px solid rgba(255,255,255,0.08); }
    .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 6px; }
    .stat { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 10px; text-align: center; }
    .stat .label { color: var(--muted); font-size: 12px; }
    .stat .value { font-weight: 800; letter-spacing: 0.5px; font-size: 20px; }
    .side { width: 220px; }
    .mini { width: 192px; height: 192px; background: var(--panel); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); margin-top: 8px; }
    .btnrow { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
    button { cursor: pointer; border-radius: 12px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.06); color: var(--text); padding: 10px 12px; font-weight: 600; }
    button:hover { background: rgba(255,255,255,0.1); }
    .footer { margin-top: 12px; font-size: 12px; color: var(--muted); text-align: center; }
    .link { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <div class="app">

    <aside class="side panel">
      <h2 class="title">Hold</h2>
      <canvas id="hold" class="mini" width="192" height="192"></canvas>
      <div class="btnrow">
        <button id="newGame">New Game (R)</button>
        <button id="pauseBtn">Pause (P)</button>
      </div>
      <div class="stats">
        <div class="stat"><div class="label">Score</div><div id="score" class="value">0</div></div>
        <div class="stat"><div class="label">Level</div><div id="level" class="value">1</div></div>
        <div class="stat"><div class="label">Lines</div><div id="lines" class="value">0</div></div>
        <div class="stat"><div class="label">Pieces</div><div id="pieces" class="value">0</div></div>
      </div>
    </aside>

    <main>
      <canvas id="board" width="360" height="720"></canvas>
      <div class="panel meta" style="margin-top:10px">
        <div><span class="kbd">←</span>/<span class="kbd">→</span> move &nbsp; <span class="kbd">↓</span> soft drop &nbsp; <span class="kbd">Space</span> hard drop</div>
        <div><span class="kbd">↑</span> rotate CW &nbsp; <span class="kbd">Z</span> rotate CCW &nbsp; <span class="kbd">C</span> hold &nbsp; <span class="kbd">P</span> pause &nbsp; <span class="kbd">R</span> restart</div>
      </div>
    </main>

    <aside class="side panel">
      <h2 class="title">Next</h2>
      <canvas id="next" class="mini" width="192" height="192"></canvas>
      <div class="footer">MIT Licensed • Build for GitHub Pages</div>
    </aside>

  </div>

  <script>
    // --- Config ---
    const COLS = 10, ROWS = 20, CELL = 36; // board canvas is 360x720
    const TICK_TABLE = [
      800, 716, 633, 550, 466, 383, 300, 216, 133, 100, 88, 76, 66, 56, 48, 41, 35, 30, 25, 21
    ]; // ms per gravity step per level (0..19)

    // Colors per piece type
    const COLORS = {
      I: '#60a5fa', J: '#93c5fd', L: '#fb923c', O: '#facc15', S: '#34d399', T: '#a78bfa', Z: '#f87171',
      X: '#1f2937' // locked cell fallback
    };

    // Tetromino definitions (Super Rotation System shapes)
    const SHAPES = {
      I: [
        [[0,1],[1,1],[2,1],[3,1]],
        [[2,0],[2,1],[2,2],[2,3]],
        [[0,2],[1,2],[2,2],[3,2]],
        [[1,0],[1,1],[1,2],[1,3]]
      ],
      J: [
        [[0,0],[0,1],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[1,2]],
        [[0,1],[1,1],[2,1],[2,2]],
        [[1,0],[1,1],[0,2],[1,2]]
      ],
      L: [
        [[2,0],[0,1],[1,1],[2,1]],
        [[1,0],[1,1],[1,2],[2,2]],
        [[0,1],[1,1],[2,1],[0,2]],
        [[0,0],[1,0],[1,1],[1,2]]
      ],
      O: [
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]]
      ],
      S: [
        [[1,0],[2,0],[0,1],[1,1]],
        [[1,0],[1,1],[2,1],[2,2]],
        [[1,1],[2,1],[0,2],[1,2]],
        [[0,0],[0,1],[1,1],[1,2]]
      ],
      T: [
        [[1,0],[0,1],[1,1],[2,1]],
        [[1,0],[1,1],[2,1],[1,2]],
        [[0,1],[1,1],[2,1],[1,2]],
        [[1,0],[0,1],[1,1],[1,2]]
      ],
      Z: [
        [[0,0],[1,0],[1,1],[2,1]],
        [[2,0],[1,1],[2,1],[1,2]],
        [[0,1],[1,1],[1,2],[2,2]],
        [[1,0],[0,1],[1,1],[0,2]]
      ]
    };

    // Wall kick data (simplified SRS). For O, no kicks.
    const KICKS = {
      normal: {
        '0>1': [[0,0],[ -1,0],[ -1, 1],[ 0,-2],[ -1,-2]],
        '1>0': [[0,0],[ 1,0],[ 1,-1],[ 0, 2],[ 1, 2]],
        '1>2': [[0,0],[ 1,0],[ 1,-1],[ 0, 2],[ 1, 2]],
        '2>1': [[0,0],[ -1,0],[ -1, 1],[ 0,-2],[ -1,-2]],
        '2>3': [[0,0],[ 1,0],[ 1, 1],[ 0,-2],[ 1,-2]],
        '3>2': [[0,0],[ -1,0],[ -1,-1],[ 0, 2],[ -1, 2]],
        '3>0': [[0,0],[ -1,0],[ -1,-1],[ 0, 2],[ -1, 2]],
        '0>3': [[0,0],[ 1,0],[ 1, 1],[ 0,-2],[ 1,-2]]
      },
      I: {
        '0>1': [[0,0],[ -2,0],[ 1,0],[ -2,-1],[ 1,2]],
        '1>0': [[0,0],[ 2,0],[ -1,0],[ 2,1],[ -1,-2]],
        '1>2': [[0,0],[ -1,0],[ 2,0],[ -1,2],[ 2,-1]],
        '2>1': [[0,0],[ 1,0],[ -2,0],[ 1,-2],[ -2,1]],
        '2>3': [[0,0],[ 2,0],[ -1,0],[ 2,1],[ -1,-2]],
        '3>2': [[0,0],[ -2,0],[ 1,0],[ -2,-1],[ 1,2]],
        '3>0': [[0,0],[ 1,0],[ -2,0],[ 1,-2],[ -2,1]],
        '0>3': [[0,0],[ -1,0],[ 2,0],[ -1,2],[ 2,-1]]
      }
    };

    // --- Helpers ---
    const $ = sel => document.querySelector(sel);
    const board = $('#board');
    const ctx = board.getContext('2d');
    const nextCanvas = $('#next').getContext('2d');
    const holdCanvas = $('#hold').getContext('2d');

    const emptyMatrix = () => Array.from({length: ROWS}, () => Array(COLS).fill(null));

    // 7-bag generator
    function* bagGenerator() {
      const types = ['I','J','L','O','S','T','Z'];
      while (true) {
        const bag = [...types];
        for (let i = bag.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [bag[i], bag[j]] = [bag[j], bag[i]];
        }
        for (const t of bag) yield t;
      }
    }

    // Piece object factory
    function makePiece(type) {
      return {
        type,
        rot: 0,
        x: 3, // spawn x
        y: -2, // spawn y (above board)
        blocks() { return SHAPES[this.type][this.rot]; }
      };
    }

    // --- Game State ---
    const State = {
      grid: emptyMatrix(),
      current: null,
      hold: null,
      canHold: true,
      queue: bagGenerator(),
      next: [],
      score: 0,
      lines: 0,
      level: 0,
      pieces: 0,
      over: false,
      paused: false,
      lastDrop: 0,
    };

    function resetGame() {
      State.grid = emptyMatrix();
      State.current = null;
      State.hold = null;
      State.canHold = true;
      State.queue = bagGenerator();
      State.next = [nextType(), nextType(), nextType(), nextType(), nextType()];
      State.score = 0; State.lines = 0; State.level = 0; State.pieces = 0; State.over = false; State.paused = false; State.lastDrop = 0;
      spawn();
      updatePanels();
    }

    function nextType() { return State.queue.next().value; }

    function spawn() {
      const type = State.next.shift();
      State.next.push(nextType());
      State.current = makePiece(type);
      State.pieces++;
      if (collides(State.current, 0, 0)) {
        State.over = true;
      }
    }

    function hold() {
      if (!State.canHold || !State.current) return;
      const cur = State.current;
      if (!State.hold) {
        State.hold = makePiece(cur.type); // store type only
        State.current = null;
        spawn();
      } else {
        const temp = State.hold.type;
        State.hold = makePiece(cur.type);
        State.current = makePiece(temp);
      }
      State.current.x = 3; State.current.y = -2; State.current.rot = 0; State.canHold = false;
    }

    function rotate(dir) {
      const piece = State.current; if (!piece) return;
      const oldRot = piece.rot;
      const newRot = (oldRot + (dir > 0 ? 1 : 3)) % 4;
      const key = `${oldRot}>${newRot}`;
      const table = (piece.type === 'I' ? KICKS.I : KICKS.normal)[key] || [[0,0]];
      for (const [dx, dy] of table) {
        if (!collides(piece, dx, dy, newRot)) {
          piece.x += dx; piece.y += dy; piece.rot = newRot; return;
        }
      }
    }

    function move(dx, dy) {
      const piece = State.current; if (!piece) return false;
      if (!collides(piece, dx, dy)) { piece.x += dx; piece.y += dy; return true; }
      return false;
    }

    function collides(piece, dx=0, dy=0, rot=piece.rot) {
      for (const [bx, by] of SHAPES[piece.type][rot]) {
        const x = piece.x + bx + dx;
        const y = piece.y + by + dy;
        if (x < 0 || x >= COLS || y >= ROWS) return true;
        if (y >= 0 && State.grid[y][x]) return true;
      }
      return false;
    }

    function lockPiece() {
      const p = State.current; if (!p) return;
      for (const [bx, by] of p.blocks()) {
        const x = p.x + bx, y = p.y + by;
        if (y >= 0) State.grid[y][x] = p.type;
      }
      State.canHold = true; clearLines(); spawn();
    }

    function clearLines() {
      let cleared = 0;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (State.grid[y].every(cell => cell)) {
          State.grid.splice(y, 1);
          State.grid.unshift(Array(COLS).fill(null));
          cleared++; y++;
        }
      }
      if (cleared) {
        const points = [0, 100, 300, 500, 800][cleared] * (State.level + 1);
        State.score += points; State.lines += cleared;
        if (Math.floor(State.lines / 10) > State.level) State.level = Math.floor(State.lines / 10);
      }
    }

    function hardDrop() {
      let dist = 0;
      while (move(0,1)) dist++;
      State.score += dist * 2; // hard drop bonus
      lockPiece();
    }

    // --- Rendering ---
    function drawCell(ctx, x, y, type, size=CELL) {
      const px = x * size, py = y * size;
      const col = COLORS[type] || COLORS.X;
      ctx.fillStyle = col;
      ctx.fillRect(px+1, py+1, size-2, size-2);
      // glossy bevel
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(px+2, py+2, size-4, (size-4)/3);
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(px+2, py+size/2, size-4, size/2-2);
    }

    function drawGrid() {
      ctx.clearRect(0,0,board.width, board.height);
      // background grid
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      for (let x=0;x<COLS;x++) {
        for (let y=0;y<ROWS;y++) {
          ctx.strokeRect(x*CELL+0.5, y*CELL+0.5, CELL-1, CELL-1);
        }
      }

      // draw locked cells
      for (let y=0;y<ROWS;y++) {
        for (let x=0;x<COLS;x++) {
          const t = State.grid[y][x]; if (t) drawCell(ctx, x, y, t);
        }
      }

      // ghost
      if (State.current) {
        const ghost = {...State.current};
        while (!collides(ghost, 0, 1)) ghost.y++;
        ctx.globalAlpha = 0.25;
        for (const [bx, by] of ghost.blocks()) drawCell(ctx, ghost.x+bx, ghost.y+by, State.current.type);
        ctx.globalAlpha = 1;
      }

      // current piece
      if (State.current) {
        for (const [bx, by] of State.current.blocks()) {
          const x = State.current.x + bx, y = State.current.y + by;
          if (y >= 0) drawCell(ctx, x, y, State.current.type);
        }
      }

      // overlays
      if (State.over) drawOverlay('Game Over', 'Press R to restart');
      else if (State.paused) drawOverlay('Paused', 'Press P to resume');
    }

    function drawOverlay(title, subtitle) {
      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(0,0,board.width, board.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = 'bold 36px ui-sans-serif, system-ui';
      ctx.fillText(title, board.width/2, board.height/2 - 10);
      ctx.font = '16px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillText(subtitle, board.width/2, board.height/2 + 20);
    }

    function drawMini(canvas, type) {
      const c = canvas; const s = 24; // mini cell size
      c.clearRect(0,0,192,192);
      if (!type) return;
      const blocks = SHAPES[type][0];
      // center in 8x8 mini-grid
      const minX = Math.min(...blocks.map(b=>b[0]));
      const maxX = Math.max(...blocks.map(b=>b[0]));
      const minY = Math.min(...blocks.map(b=>b[1]));
      const maxY = Math.max(...blocks.map(b=>b[1]));
      const w = (maxX-minX+1), h=(maxY-minY+1);
      const offX = Math.floor((8-w)/2) - minX;
      const offY = Math.floor((8-h)/2) - minY;
      blocks.forEach(([bx,by]) => drawCell(c, bx+offX, by+offY, type, s));
    }

    function drawSidePanels() {
      drawMini(nextCanvas, State.next[0]);
      drawMini(holdCanvas, State.hold?.type);
    }

    function updatePanels() {
      $('#score').textContent = State.score;
      $('#level').textContent = State.level + 1; // user-facing levels start at 1
      $('#lines').textContent = State.lines;
      $('#pieces').textContent = State.pieces;
      drawSidePanels();
    }

    // --- Game Loop ---
    let rafId = null;
    function loop(ts) {
      if (State.over || State.paused) { drawGrid(); updatePanels(); rafId = requestAnimationFrame(loop); return; }
      if (!State.lastDrop) State.lastDrop = ts;
      const tick = TICK_TABLE[Math.min(State.level, TICK_TABLE.length-1)];
      if (ts - State.lastDrop >= tick) {
        if (!move(0,1)) lockPiece();
        State.lastDrop = ts;
      }
      drawGrid(); updatePanels();
      rafId = requestAnimationFrame(loop);
    }

    function start() { cancelAnimationFrame(rafId); State.lastDrop = 0; rafId = requestAnimationFrame(loop); }

    // --- Input ---
    const keys = new Set();
    document.addEventListener('keydown', e => {
      if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' ','z','Z','c','C','p','P','r','R'].includes(e.key)) e.preventDefault();
      if (State.over && (e.key==='r' || e.key==='R')) { resetGame(); return; }
      if (State.paused && (e.key==='p' || e.key==='P')) { State.paused = false; return; }
      switch (e.key) {
        case 'ArrowLeft': move(-1,0); break;
        case 'ArrowRight': move(1,0); break;
        case 'ArrowDown': if (move(0,1)) State.score += 1; break; // soft drop bonus
        case ' ': hardDrop(); break;
        case 'ArrowUp': rotate(1); break;
        case 'z': case 'Z': rotate(-1); break;
        case 'c': case 'C': hold(); break;
        case 'p': case 'P': State.paused = !State.paused; break;
        case 'r': case 'R': resetGame(); break;
      }
    });

    // Buttons
    $('#newGame').addEventListener('click', resetGame);
    $('#pauseBtn').addEventListener('click', () => State.paused = !State.paused);

    // --- Boot ---
    resetGame();
    start();
  </script>
</body>
</html>
